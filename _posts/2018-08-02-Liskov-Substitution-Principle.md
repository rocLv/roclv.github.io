---
layout: post
title:  里氏替换原则
date:   2018-08-03 16:16:01 -0600
categories: SOLID
---

   SOLID原则之二： 你应该总是可以用子类来替换父类，而且不会出现任何问题。
<!-- more -->



>
    你应该总是可以用子类来替换父类，而且不会出现任何问题。

或者说

>
    假如 S 是 T 的子类型，那么程序里用类型为 T 的对象也可以用类型为
S的对象替换。替换后不会改变程序的任何属性。


实践中，子类应该总是扩展父类，根本不会改变它们的行为。

下面的代码显示了最经典的违反LSP的例子：

```ruby
class Rectangle
  attr_accessor :width, :height

  def caculate_area
    width * height
  end
end

class Square
  def width=(height)
    super(width)
    @height = width
  end

  def height=(width)
    super(height)
    @width = height
  end
end


  rectangle = Rectangle.new
  rectangle.height = 10
  rectangle.width = 5

  rectangle.caculate_area #=> 50

  square = Square.new
  square.width = 10
  square.height = 5

  square.caculate_area #=> 25
```

从数学的角度来看，没什么问题。这个是正方体，所以它一定有相同的长和宽。我们把高设为10，然后我们又把宽设为5，
然后我们计算面积。

我们按照相同的步骤，但是父类和子类得出的结果却不一致。

### LSP 和多态

有一个问题必须说一下。不是因为我们接收不同的结果，我们说违反了原则，而是我们得到了我们不期望的结果，才说我们违反了原则。

请考虑一下下面的例子：

```ruby

class Shape
  def draw
    raise NoImplementedError
  end
end

class Rectangle < Shape
  def draw
    # Draw something
  end
end

class Circle < Shape
  def draw
    # Draw circle
  end
end

```

draw方法依据不同的子类画出了不同的图形，但是它们画的图形是我们预料中的。

让我们考虑一下这个。假如收到不同的结果是违法了 LSP，那么使用多态，它是 OOP
中最有力量的工具，将总是违反它。当我们覆盖父类的方法时，我们不应该改变它的行为，但是我们可以
根据子类的特点扩展它的行为。

    >
     不能再子类中加强先决条件，也不能在子类中削弱后天条件。
或换句话说

    >
      子类不应该要求更多条件，也不能减少承诺。

遵循 LSP 允许我们更自信地使用多态。我们可以退回到父类中调用方法而不必用担心产生我们
不期望的结果

### 问题在那？

问题出在我们的抽象。正方体是矩形在数学是成立的，但是在编程的环境里不成立（至少在这个情况下）。我们只是错误的模型化我们的抽象。

### 为什么我爱这个例子？

因为它反映了 OOP 中一个很重要的东西。OOP 不只是简单的真实世界到对象的映射。OOP
是创造抽象，而不是创造概念！

### 是时候引入一些提高了

老实说，没有完美的解决方案（总是如此）。
1.
识别这些类有没有共同的行为。不要捆绑这两个类--只是用他们自己的行为创建两个单独的类。

2. 添加另一层的抽象来“模拟”接口类型（也可以通过继承解决，就是方法不同而已）

第二种解决方法：

```ruby
class Shape
  def caculate_area
    raise NotImplementedError
  end
end

class Rectangle < Shape
  attr_accessor :height, :width

  def caculate_area
    width * height
  end
end


class Square < Shape
  attr_accessor :side_length

  def caculate_area
    side_length ** 2
  end
end

```

这种实现最大的缺点是什么？我们可以源于基类（和真实接口正好相反 -
当然我们不需要基础只接口，我们实现它）。所以加入有一个理由来通过这些类来分析别的行为，我们的解决方案就可以阻止它。

无论如何，我们仍然说的是
Ruby，一种动态类型的语言。我们不一定非要这样做。感觉最重要。企图强迫把静态类型的语言的一些解决方案加在动态类型语言的身上可能并不总是最好的想法。

### LSP是好的继承的决定性因素吗？

组合优于继承。你可能已经听说这句话。但是有时我们真的需要/想要/必须适应继承，这没有错。
它是 OOP 的一部分，也是 OOP 真正有力的一部分。完成 LSP
可能是正确使用了继承关系的一个一个征兆。

你应该问你自己两个问题：
1. B 想要暴露A 的完整的接口（所有公共方法），这样 B 可以在需要用A 的地方使用？

  ** 它（可能）暗示了继承的需要**
2. B 仅希望暴露A 的部分行为？
  **它（可能）按时需要组合**

所以，我们可以使用 LSP 做完下面问题的一个测试。

#### 我需要继承这个类吗？

**重要：** 当然，这不是仅有的决定因素。记得主要的问题是：“是否 A 是
B？”然而上面的这两个问题可以帮你做决定，但是他们不是解决方法。

创建好的继承关系是一个完整的单独的主题，甚至可以写一本书。我想要说的是满足LSP是创建好的继承关系必须满足的
，不是仅有的条件。

### 违反LSP的现象

我们可以观察一些违反 LSP 典型的信号：

* 子类复写了基类的方法，给了他完全新的行为
* 子类用空方法复写了父类的方法
* 子类不调用有些父类的方法
* 抛出额外的异常

总结：

你可能已经注意到了，我们在 Ruby 的上下文中分析这些原则，Ruby
是一种动态类型的语言。所以这个特殊的原则可能好像不是很重要。然而，无论从那个角度来说，
我都不会低估这个原则的重要性。

没有人强迫我们保持我们的接口一直。我们甚至可以在子类返回不同于父类的类型。但是我们应该以哪种方式编码吗？
我不认为。我认为那将是非常差的实践。就像创建了可以返回空数组，逻辑变量或者字符串一样。

结论和简单。好的 OOP 实践总是值得称赞的 --
不管我们用什么语言。另外，感觉也很重要。让我们使用动态语言的好处，但是以一个负责任的态度。

动态语言给了我们更多的灵活性，但是我个人认为这并没有让我们写 OOP
更容易。我们必须更小心，也要主动约束我们自己。
